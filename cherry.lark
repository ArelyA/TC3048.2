start: (stmt_ext)*

// Functions can only be defined in the global context
stmt_ext: stmt
  | def_func

// Functions that can be declared within an stmt block
?stmt: asign
  | if_else
  | print
  | for
  | while
  | read
  | call_func
  | write

// Stmt block defined with proper indentation
block: ("\t" stmt)+

// Assignment
?asign: asign_simp
  | asign_item

// Simple
asign_simp: id "=" asign_simp_opt 
asign_simp_func: -> asign_simp_func
?asign_simp_opt: var_it // TODO
  | expresion asign_simp_func
  | var_str asign_simp_func
  | cte_file asign_simp_func
  | call_func // TODO

// Item
asign_item: id "[" put_fondo expresion "]" asign_item_func "=" asign_item_opt asign_simp_func
asign_item_func: -> asign_item_func
asign_item_opt: expresion
  | var_str
  | call_func
  | cte_file


call_func: ID "(" call_func_opt ("," call_func_opt)* ")" // Si existe y tiene tipo de retorno Crea una variable de nombre idFunc
call_func_opt: expresion
  | func_str
  | func_it

print: "print" "(" put_fondo print_opt ("," print_opt)* ")" print_func // poppea mientras no sea fondo (
put_fondo: -> put_fondo
print_func: -> print_func
print_opt: var_str
  | expresion

write: write_opt ".write" "(" write_opt ")"
// Copia del primer archivo al segundo y si el izq es temp lo borra 
// Si el de la izq no existe manda error
write_opt: cte_file
  | id // revisa si id existe
read: "read" "(" id ["," read_opt] ")" // If operando.top == int, float, string o file: poppea 2 veces, sino solo 1
// If id no existe lo crea
!read_opt: "int"
  | "float"
  | "string"
  | "file"


if_else: "if" "(" expresion ")" ":" block ["else" ":" block]

while: "while" "(" expresion ")" ":" block
for: "for" id "in" for_opt check_it ":" block
//id_for: ID -> id_for // Si ya existe la usa y si no la agrega
check_it: -> check_it // Revisa que la variable que se usa es iterativa
for_opt: var_it_ext

def_func: "def" def_func_name "(" [def_func_param ("," def_func_param)*] ")" ":" block ["return" def_func_opt def_func_type] 
def_func_name: ID -> def_func_name //Revisar si existe
def_func_param: ID -> def_func_param //Aqui tambiÃ©n
def_func_type: -> def_func_type
def_func_opt: expresion
  | var_str
  | var_it


func_cte: len
  | count
  | size
len: "len(" len_opt ")"
len_opt: var_it
  | var_str
count: var_it_ext ".count(" count_opt ")"
count_opt: var_str
  | expresion
size: "size(" CTE_FILE ")"

func_str: substr
  | join
  | find
  | norm
  | clean
substr: var_str_ext "[" expresion ":" expresion "]"
join: var_str_ext ".join(" var_it ")"
find: var_str_ext ".find(" var_str ")"
clean: opts ".clean(" ")"
norm: opts ".norm(" var_str ")"
opts: var_str_ext | cte_file
?var_cte: CTE_INT -> int_func
  | CTE_FLOAT -> float_func
  | CTE_BOOL -> bool_func
  | id
  | id "[" expresion "]" // Punto, saca 2 operandos
  | func_cte
?var_it: func_it
  | "[" var_it_fondo var_it_opt ("," var_it_opt)* "]" var_it_asign
var_it_fondo: -> var_it_fondo // agrega fondo falso
var_it_asign: -> var_it_asign // is left tipo ID crea var y genera arreglo, else crea varTemp y genera arreglo
?cte_file: CTE_FILE -> file_func
?var_it_opt: expresion
  | var_str
?var_str: CTE_STRING -> string_func
  | func_str
?var_str_ext: var_str
  | id
?var_it_ext: var_it
  | id
id: ID -> id_func

func_it: range
  | tokenize
  | unigrams
  | bigrams
  | ngrams
  | set
tokenize: var_str_ext ".tokenize(" tokenize_opt? ")"
!tokenize_opt: "word"
  | "sentence"
unigrams: var_str_ext ".unigrams(" ")"
bigrams: var_str_ext ".bigrams(" ")"
ngrams: var_str_ext ".ngrams(" expresion ")"
range: "range(" expresion ("," expresion)~0..2 ")"
set: var_it_ext ".set(" ")"

?expresion: expresion_and or_func (or_func_op expresion_and or_func)*
?expresion_and: ass and_func (and_func_op ass and_func)*
and_func_op: EXPRESION_AND -> and_func_op
and_func: -> and_func
or_func_op: EXPRESION_OR -> or_func_op
not_func: -> not_func
or_func: -> or_func
EXPRESION_AND: "and"
EXPRESION_OR: "or"
?ass: comp not_func
  | not_func_op comp not_func
NOT: "not"
not_func_op: NOT -> not_func_op
comp: exp comp_func [comp_func_op exp comp_func]
comp_func_op: COMP_OPT -> comp_func_op
comp_func: -> comp_func
COMP_OPT: ">"
  | ">="
  | "<"
  | "<="
  | "=="
  | "!="
exp: term exp_func
  | term exp_func exp_opt exp
exp_opt: EXP_OPT  -> exp_func_op
exp_func: -> exp_func
EXP_OPT: "+"
  | "-"
term: factor term_func
  | factor term_func term_opt term 
term_opt: TERM_OPT -> term_func_op
term_func: -> term_func
TERM_OPT: "*" | "/" 
factor: "(" factor_paren expresion ")" factor_paren_end
  | var_cte
factor_paren: -> factor_paren
factor_paren_end: -> factor_paren_end
CTE_BOOL.6: "True"  | "False" // BOOL terminal
CTE_FILE: /(\.{0,2}\/){0,1}[\d\w\_\-]+[\d\w\_\-\/]*[\d\w\_\-]+\./ (/txt/ | /html/ | /htm/)~1
// imports from terminal library
%import common.CNAME -> ID // ID terminal
%import common.ESCAPED_STRING -> CTE_STRING // STRING terminal
%import common.SIGNED_INT -> CTE_INT // INT terminal
%import common.SIGNED_FLOAT -> CTE_FLOAT //FLOAT terminal
%import common.SH_COMMENT
%import common.CPP_COMMENT
%import common.C_COMMENT

WHITESPACE: /[ \f\r\n]/+

%ignore WHITESPACE // Disregard spaces in text
%ignore SH_COMMENT
%ignore  CPP_COMMENT
%ignore  C_COMMENT
  