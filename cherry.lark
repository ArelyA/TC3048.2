start: (stmt_ext)* end_prog
end_prog: -> end_prog

// Functions can only be defined in the global context
stmt_ext: stmt
  | def_func // TODO

// Functions that can be declared within an stmt block
?stmt: asign
  | if_else // TODO
  | print // TODO
  | for // TODO
  | while // TODO
  | read // TODO
  | call_func // TODO
  | write // TODO

// Stmt block defined with proper indentation
block: ("\t" stmt)+

// Assignment
?asign: asign_simp // DONE
  | asign_item // DONE

// Simple
asign_simp: id asign_op asign_simp_opt 
?asign_simp_func: -> asign_simp_func
?asign_simp_opt: var_it // TODO - func_it
  | expresion asign_simp_func
  | call_func // TODO
!asign_op: "=" -> asign_op
// Item
asign_item: id "[" expresion asign_item_index asign_op asign_item_opt 
asign_item_func: -> asign_item_func
asign_item_index: "]" -> asign_item_index
asign_item_opt: expresion asign_item_func
  | call_func // TODO



call_func: call_func_name "(" call_func_opt ("," call_func_opt)* call_func_param // Si existe y tiene tipo de retorno Crea una variable de nombre idFunc
call_func_opt: expresion
  | func_it

call_func_name: ID -> call_func_name // ADD TOPE
cal_func_param: ")" -> call_func_param
print: "print" put_fondo print_opt ("," print_opt)* ")" print_func
!put_fondo: "(" -> put_fondo
print_func: -> print_func
print_opt: expresion
  | var_it

write: write_opt ".write" "(" write_opt ")"
// Copia del primer archivo al segundo y si el izq es temp lo borra 
// Si el de la izq no existe manda error
write_opt: cte_file
  | id // revisa si id existe
read: "read" "(" id ["," read_opt] ")" // If operando.top == int, float, string o file: poppea 2 veces, sino solo 1
// If id no existe lo crea
!read_opt: "int"
  | "float"
  | "string"
  | "file"


if_else: "if" expresion if_func block [else_func ":" block] endif
!if_func: ":" -> if_func // DONE
!else_func: "else" -> else_func // DONE
endif: -> endif // DONE

while: "while" while_func expresion while_cond block while_end
while_func: -> while_func // DONE
while_cond: ":" -> while_cond // DONE
while_end: -> while_end // DONE

for: "for" id "in" for_opt for_check block for_end
for_check: ":" -> for_check // DONE
for_end: -> for_end // DONE
for_opt: var_it_ext
  | range // Tipo INT
  

def_func: "def" def_func_name "(" [def_func_param ("," def_func_param)*] ")" ":" block [RETURN def_func_opt def_func_type] def_func_end
RETURN.10: "\t" "return"
def_func_name: ID -> def_func_name // DONE
def_func_param: ID -> def_func_param_func // DONE
  | id "[" cte_int def_func_param_it // DONE
!def_func_param_it: "]" -> def_func_param_it // DONE
def_func_type: -> def_func_type // DONE
def_func_end: -> def_func_end // DONE
def_func_opt: expresion
  | var_it

func_cte: len
  | count
  | size
  | find
len: "len(" len_opt ")"
len_opt: var_it
  | var_str
count: var_it_ext ".count(" count_opt ")"
count_opt: expresion
//  | var_str
size: "size(" CTE_FILE ")"
find: var_str_ext ".find(" var_str_ext ")"

func_str: substr
  | join
  | norm
  | clean
substr: var_str_ext "[" expresion ":" expresion "]"
join: var_str_ext ".join(" var_it ")"
clean: opts ".clean(" ")"
norm: opts ".norm(" var_str ")"
opts: var_str_ext | cte_file

?var_cte: CTE_INT -> int_func
  | CTE_FLOAT -> float_func
  | CTE_BOOL -> bool_func
  | cte_file
  | id
  | id "[" expresion asign_item_index
  | func_cte
  | var_str
  
cte_int: CTE_INT -> cte_int
?var_it: func_it // TODO - IF ASIGN (OP == '=') DO SMTHN ELSE DO NOTHING
  | "[" var_it_fondo var_it_opt ("," var_it_opt)* var_it_asign

var_it_fondo: -> var_it_fondo 
!var_it_asign: "]" -> var_it_asign 

?cte_file: CTE_FILE -> file_func
?var_it_opt: expresion
//  | var_str

?var_str: CTE_STRING -> string_func
  | func_str // TODO

?var_str_ext: var_str
  | id
?var_it_ext: var_it
  | id
id: ID -> id_func

func_it: set
  | getline
  | getword
  | append
range: "range(" expresion ("," expresion)~0..2 ")"
set: var_it_ext ".set(" ")" // ASIGNA EN NUEVA VARIABLE
getline: cte_file "." "getLine" "(" expresion ")"
getword: cte_file "." "getWord" "(" expresion ")"
append: "append" "(" var_it_ext "," var_it_ext ")"

// DONE
?expresion: expresion_and or_func (or_func_op expresion_and or_func)*
?expresion_and: ass and_func (and_func_op ass and_func)*
and_func_op: EXPRESION_AND -> and_func_op
and_func: -> and_func
or_func_op: EXPRESION_OR -> or_func_op
not_func: -> not_func
or_func: -> or_func
EXPRESION_AND: "and"
EXPRESION_OR: "or"
?ass: comp not_func
  | not_func_op comp not_func
NOT: "not"
not_func_op: NOT -> not_func_op
comp: exp comp_func [comp_func_op exp comp_func]
comp_func_op: COMP_OPT -> comp_func_op
comp_func: -> comp_func
COMP_OPT: ">"
  | ">="
  | "<"
  | "<="
  | "=="
  | "!="
exp: term exp_func
  | term exp_func exp_opt exp
exp_opt: EXP_OPT  -> exp_func_op
exp_func: -> exp_func
EXP_OPT: "+"
  | "-"
term: factor term_func
  | factor term_func term_opt term 
term_opt: TERM_OPT -> term_func_op
term_func: -> term_func
TERM_OPT: "*" | "/" 
factor: "(" factor_paren expresion ")" factor_paren_end
  | var_cte
factor_paren: -> factor_paren
factor_paren_end: -> factor_paren_end
CTE_BOOL.6: "True"  | "False" // BOOL terminal
CTE_FILE: /(\.{0,2}\/){0,1}[\d\w\_\-]+[\d\w\_\-\/]*[\d\w\_\-]+\./ (/txt/ | /html/ | /htm/)~1
// imports from terminal library
%import common.CNAME -> ID // ID terminal
%import common.ESCAPED_STRING -> CTE_STRING // STRING terminal
%import common.SIGNED_INT -> CTE_INT // INT terminal
%import common.SIGNED_FLOAT -> CTE_FLOAT //FLOAT terminal
%import common.SH_COMMENT
%import common.CPP_COMMENT
%import common.C_COMMENT

WHITESPACE: /[ \f\r\n]/+

%ignore WHITESPACE // Disregard spaces in text
%ignore SH_COMMENT
%ignore  CPP_COMMENT
%ignore  C_COMMENT
  